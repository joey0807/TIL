# 시퀀스 타입

- 기본 타입(숫자, 문자열)으로 이루어진 여러개의 자료를 하나의 자료형으로 다루기 위한 방법
  -  문자열은 엄밀하게 따지면 기본 타입은 아님
  - 다른 언어에선 `배열`이라고 표현

- 파이썬의 시퀀스 타입은 가장 기본적인 `자료구조`의 한 종류
  - 자료구조 : 여러 개의 자료를 관리하는 방법

- 파이썬에서 제공하는 시퀀스 종류

  - 리스트
    - 다른 언어에서 제공하는 `배열`의 개념
    - 가장 많이 사용하는 자료형
    - `선형자료구조`

   - 튜플(tuple)
     - 자료의 값을 변경할 수 있느냐 없느냐의 차이를 제외하고는 리스트와 동일
     - 튜플 내의 자료들의 값이 변하지 않음

   - 레인지(range)
     - 수열 생성

## 불가변형 타입 vs 가변형 타입

- 불가변형 타입
  - 대표적으로 튜플
  - 자료들의 값을 바꿀 수 없음

- 가변형 타입
  - 대표적으로 리스트
  - 자료들의 값을 바꿀 수 있다

## 튜플(tuple)

- 불가변형의 대표적인 타입
- 문자열은 튜플의 한 종류

``` python
#빈 튜플을 만드는 방법
arr = () #원소가 하나도 없는 튜플 - 빈 문자와 동일한 개념
type(arr)
```

``` 
tuple
```

``` python
#튜플이 되려면 원소가 한 개 이상 존재해야 함
#콤마가 있다는 것은 연속된 자료의 종류라고 판단
arr = (1,)
print(type(arr))
print(arr)
```

``` 
<class 'tuple'>
(1,)
```

``` python
arr = (1,2,3,4,5)
print(type(arr))
print(arr)
```

``` 
<class 'tuple'>
(1,2,3,4,5)
```

### 공통 연산자

- 가변형 타입과 불가변형 타입 모두 동일하게 사용
- [파이썬 시퀀스 타입 공식 문서](https://docs.python.org/ko/3/library/stdtypes.html#sequence-types-list-tuple-range)

``` python
arr = (10,20,30,40,50)
print(arr)
```

``` 
(10,20,30,40,50)
```

``` python
#시퀀스 내의 원소를 검색하는 경우
print(10 in arr)
print(100 in arr)
print(10 not in arr)
print(100 not in arr)
```

``` 
True
False
False
True
```

튜플도 문자열과 마찬가지로 덧셈과 곱셈 연산이 가능

- 리스트도 동일하게 사용 가능
- 내용은 문자열과 동일

```python
print(arr + (100,200,300))
print(arr * 3)
```

``` 
(10, 20, 30, 40, 50, 100, 200, 300)
(10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 10, 20, 30, 40, 50)
```

튜플인데 변경이 가능?

- 원본은 변하지 않음
- arr 튜플과 새로운 튜플을 합친 새로운 튜플을 반환

#### 인덱싱과 슬라이스

- 파이썬의 시퀀스 타입은 자동으로 인덱스가 생성
  - 0부터 순차적으로 1씩 증가하면서 자동으로 번호가 매겨짐
  - 튜플(리스트)의 첫 번째 원소의 인덱스는 0
  - 인덱스는 시퀀스 내에서 참조하길 원하는 원소를 선택
- 슬라이스는 시퀀스 내에서 원하는 범위의 요소를 선택
  - 정확하게는 잘라서 가져오는 개념
- 핵심은
  - 반복문과 반복문을 이용한 인덱싱

``` python
# 내가 원하는 원소만 선택
print( arr[0] ) # arr 튜플의 첫 번째 원소
print( arr[1] )
print( arr[2] )
print( arr[3] )
print( arr[4] )
```

``` 
10
20
30
40
50
```

중요! 주어진 시퀀스 타입의 범위를 벗어나는 참조

- `Index Out of Range`

``` python
print(arr[5])
```

``` 
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-40-af8fab70edd1> in <module>()
----> 1 print( arr[5] )

IndexError: tuple index out of range
```

``` python
# len는 시퀀스의 크기(길이)를 반환해줍니다. 
# 시퀀스의 크기는 원소의 개수를 의미합니다. 
print(len(arr))
# 시퀀스의 크기와 상관 없이 항상 마지막 원소를 참조하고 싶다면? 
print( arr[ len(arr) - 1] )
```

``` 
5
50
```

파이썬은 음수 인덱스를 지원

- 음수 인덱스도 자동으로 생성
- 시퀀스 타입의 가장 마지막 원소부터 -1로 시작해서 순차적으로 1씩 감소하면서 번호 생성

``` python
print(arr)
print(arr[-1])
print(arr[-2])
print(arr[-3])
print(arr[-4])
print(arr[-5])
```

``` 
(10, 20, 30, 40, 50)
50
40
30
20
10
```

``` python
# 시퀀스의 크기와 상관없이 항상 마지막 원소를 참조 할 수 있음
print( arr[-1] )
```

```
50
```

슬라이스는 범위 내의 원소를 잘라오는 기능

- 멀티 인덱스 용도로 많이 사용
- 슬라이스의 사용법

``` 
s[시작인덱스 : 끝인덱스]
```

``` python
# 중간에 20, 30, 40 3개의 원소만 선택을 하고 싶다면? 
# 파이썬에서 슬라이스를 하는 경우 끝인덱스의 원소는 포함하지 않습니다
print( arr[1:4] )
```

``` 
(20,30,40)
```

슬라이스의 여러가지 형태

``` python
# 전체 원소를 전부 선택
# 슬라이스를 하는 경우에는 마지막 인덱스의 범위를 확인하지 않음
print( arr[0:5])

# 그래서 이렇게 써도 되긴 함
print( arr[0:99999999999999999999] )

# 시작 인덱스와 끝 인덱스는 생략 가능 
# 시작 인덱스가 생략되면 무조건 첫 번째 원소부터
# 끝 인덱스가 생략되면 무조건 마지막 원소까지
print( arr[:] )

# 시작위치가 생략되면 첫 번째 원소부터
print( arr[:4] )

# 끝 인덱스가 생략되면 마지막 원소까지
print( arr[1:] )
```

``` 
(10, 20, 30, 40, 50)
(10, 20, 30, 40, 50)
(10, 20, 30, 40, 50)
(10, 20, 30, 40)
(20, 30, 40, 50)
```

```python
# k의 기본값은 1이고, 생략 가능한 형태
print( arr[0:4:1] )
print( arr[::1] )

# 짝수번째 인덱스의 원소만 선택
print( arr[::2]) # 0, 2, 4, 6, 8, ... (k씩 증가)

# 홀수번째 인덱스의 원소만 선택
print( arr[1::2]) # 1, 3, 5, 7, 9, ... (k씩 증가)

# 음수 인덱스
print( arr[-1:-6:-1] ) # -1, -2, -3, -4, ... 

# 시퀀스에 대해서 매우 쉽게 reverse 연산이 가능
print( arr[::-1] )
```

```
(10, 20, 30, 40)
(10, 20, 30, 40, 50)
(10, 30, 50)
(20, 40)
(50, 40, 30, 20, 10)
(50, 40, 30, 20, 10)
```

``` python
#최댓값과 최솟값
print( min(arr) )
print( max(arr) )
```

``` 
10
50
```

### 문자열

- 문자열도 시퀀스 타입의 한 종류
  - 튜플의 한 종류
  - 그래서 문자열도 튜플처럼 사용 가능
  - 튜플의 속성 + 문자열의 속성

``` python
string = 'hello'
print( string[0] )
print( string[::2])
print( string[::-1] )
```

``` 
h
hlo
olleh
```

### 가변 연산자

- 가변형 타입에서만 사용가능한 명령어(연산)
- 튜플에서는 확인할 수 없음

## 리스트(list)

- 파이썬에서 가장 많이 사용하는 자료형
- 다른 언어에선 `배열`이라고 부름

``` python
# 빈 리스트를 만드는 방법
arr = []
print(type( arr ))
# 초기화된 리스트를 만드는 방법
arr = [10, 20, 30, 40]
print(arr)
```

``` 
<class 'list'>
[10, 20, 30, 40]
```

### 공통 연산자

- 튜플과 동일
- 똑같이 사용 가능

### 가변 연산자

```python
strings = 'Hello'
print( strings[1] )

# 대문자 'H'를 소문자로 바꾸고자 한다면?
strings[0] = 'h'
```

```
e
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-101-ea88a07ffcbd> in <module>()
      3 
      4 # 대문자 'H'를 소문자로 바꾸고자 한다면?
----> 5 strings[0] = 'h'

TypeError: 'str' object does not support item assignment
```

```python
print( arr )
arr[0] = 1
print( arr )
```

```
[10, 20, 30, 40]
[1, 20, 30, 40]
```

#### append vs extend

- 리스트에 원소를 추가하는 명령어
- 리스트에서만 사용 가능
- 원소를 하나만 추가하는 경우와 여러 개를 한꺼번에 추가하는 경우

``` python
print( arr )

# append를 이용하면 리스트에 가장 마지막(맨 끝)에 원소를 추가
# 이때, 명령어를 실행한 결과를 반환하지 않습니다.
arr.append(50)
print( arr ) # 이런 경우에는 직접 확인을 해주면 됩니다. 
```

```
[10, 20, 30, 40]
[10, 20, 30, 40, 50]
```

돌려주는 경우 vs 돌려주지 않는 경우

- 원본 자료형이 직접 바뀌는 경우에는 돌려주지 않음
- 파이썬에서 돌려주는 경우 : 새로운 자료가 만들어진 경우에만

```python
# 원소 여러개를 추가하는 경우
# 리스트와 리스트를 더해서 변수를 새로 할당
# extend를 이용하는 방법은 동일한 명령어
arr = [1, 2, 3, 4]
print(arr)

# 마찬가지로 명령어를 실행환 결과를 반환하지 않습니다. 
arr.extend([5, 6, 7])
```

``` 
[1, 2, 3, 4]
```

```python
print(arr)
```

```
[1, 2, 3, 4, 5, 6, 7]
```

왜 출력이 되지 않을까

- 반환되는 경우와 반환되지 않는 경우의 차이

```python
arr = [1, 2, 3, 4]
print( arr + [5, 6, 7] )
```

```
[1, 2, 3, 4, 5, 6, 7]
```

```python
# print 명령에 들어가는 입력이 없음
print( arr.append(5) )
```

```
None
```

#### append vs insert

- append : 리스트의 맨 뒤(끝)에 추가
- insert : 리스트 중 원하는 위치에 원소를 삽입하는 형태

```python
arr = [10, 20, 30, 40, 50]
arr
```

```
[10, 20, 30, 40, 50]
```

```python
# 역시 반환값은 없습니다
arr.insert(2, 25)
```

```python
# 하지만, 확인해보면 반영이 되어 있는 것을 알 수 있습니다. 
arr
```

```
[10, 20, 25, 30, 40, 50]
```

## range

- 범위 내의 수열을 생성
- 정수만 가능
- 반복문과 함께 가장 많이 쓰이는 명령어
- range의 기본적인 형태

```
range(start, end)
```

 ```python
 # range의 일반적인 사용법
 # 마지막 수는 포함되지 않음
 range(1, 10) # 1, 2, 3, 4, 5, 6, 7, 8, 9
 ```

```
range(1,10)
```

``` python
# 실제로 수열을 확인해보고 싶다면
# 리스트로 변환 해보면 확인이 가능
list( range(1, 10) )
```

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

range의 여러가지 형태

- 사용법은 슬라이스와 비슷함

```python
# start는 생략이 가능(0부터 수열을 생성)
# start만 생략이 가능
range(10)
```

```
range(0, 10)
```

```python
# end를 생략할 수는 없습니다. 
# end가 0인 수열을 의미
range(0)
```

```
range(0, 0)
```

```python
# step은 생략이 가능한 형태로, 기본값이 1
range(1, 10, 1)

# 짝수 수열
print( list( range(0, 10, 2) ) )

# 홀수 수열
print( list( range(1, 10, 2) ) )
```

```
[0, 2, 4, 6, 8]
[1, 3, 5, 7, 9]
```

