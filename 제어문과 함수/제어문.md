# 제어문

- 거의 대부분의 언어가 비슷함
  -  2개지의 제어문을 가지고 전체 코드의 실행 흐름을 제어
  - 분기문 & 반복문

## 분기문(조건문)

- 파이썬은 `if` 하나만 제공
- 기본적인 형태

``` python
if 명제 :
[들여쓰기(tab)] 명령어들 ...
```

### 들여쓰기

- 파이썬에서는 반드시 모든 명령어들이 잘 정렬되어 있어야 한다
- 들여쓰기는 매우 중요

``` python
# 파이썬은 반드시 모든 명령어를 정렬해줘야 합니다. 
print('hello')
  print('python')
```

```
File "<ipython-input-6-45d69fab1847>", line 3
    print('python')
    ^
IndentationError: unexpected inden
```

파이썬은 블록 표현 : 들여쓰기를 이용

- 같은 들여쓰기를 해야 같은 블록으로 인식
  - 들여쓰기를 할 때, 탭과 공백을 구분
  - 반드시 같은 문자로, 같은 크기만큼 들여쓰기를 해야 함

### 다양한 형태의 if문들

```python
# 파이썬은 빈 블록을 허용하지 않음
# 블록 내에 반드시 1개 이상의 명령어를 포함해야 함
if 1 in mem:
```

```
File "<ipython-input-15-50368f684e76>", line 2
    if 1 in mem:
                ^
SyntaxError: unexpected EOF while parsing
```

```python
# 빈 블록을 작성하고 싶다면 pass를 이용
# pass를 적어주면, 예외가 발생하는 것을 막을 수 있다
if 1 in mem: 
  pass
```

#### if-else

``` python
# 거짓인 경우에 실행할 수 있는 블록을 추가
# 둘 중에 하나는 반드시 분기된다.

if 10 in mem:
  # if블록
  print('명제가 참인 경우에 실행')
else:
  # else 블록
  print('명제가 거짓인 경우에 실행')
```

```
명제가 거짓인 경우에 실행
```

if 블록과 else 블록 중에 한 곳으로는 반드시 분기됨

- 두 블록 모두 실행이 되거나, 두 블록이 모두 실행이 되지 않는 경우는 발생할 수 없음
- 무조건 어느 한 블록으로는 분기

그렇지 않다는 것은

- 두 블록이 모두 실행이 되는 경우
  - 참 거짓이 동시에 존재
  - 어떤 명제가 참인 동시에 거짓인 경우는 없음

- 두 블록이 모두 실행이 안되는 경우
  - 어떤 면제가 참 거짓이 모두 아닌 경우는 없음

#### 다중조건(elif)

``` python
# 다중조건에서는 첫번째 조건부터 차례대로 전부 비교하면서 실행
# 이때, 첫 번째로 참이 되는 블록의 명령어를 수행
# 나머지 조건은 검사하지 않습니다. 
# 한개라도 참이되는 조건이 없다면, 마지막 else 블록이 실행이 됩니다. 

# 다중조건인 경우에는 여러개의 분기중의 하나의 블록으로만 분기가 됩니다. 
if 1 in mem:
  print('참')
elif 2 in mem:
  print('참')
elif 3 in mem:
  print('참')
else:
  print('거짓')
```

```
참
```

``` python
# 다중조건이 아닙니다.
if 1 in mem:
  print('참')

if 2 in mem:
  print('참')

if 3 in mem:
  print('참')
else:
  print('거짓')
```

```
참
참
참
```

비슷한 표현을 논리연산과 함께 사용 가능

- 다중조건과 비슷하게 구현할 수 있는데
- 논리연산만으론 다중조건을 완벽하게 표현할 수 없음

``` python
if (1 in mem) or (2 in mem) or (3 in mem):
  print('참')
else:
  print('거짓')
```

```
참
```

## 반복문

- 파이썬의 2가지 형태의 반복문
  - while
  - for

### while

- 기본적인 형태는 if와 크게 다르지 않음
- if가 명제를 한번만 검사를 하고 분기를 한다면
- while은 명제를 여러번 검사함
  - 틀릴 떄 / 거짓일 때
  - 반복적으로 분기

``` python
while 명제 :
    while 블록
```

``` python
cnt = 0

# 제대로 종료가 되려면? 언젠가는 명제가 거짓이 되도록 만들어줘야 함
while cnt < 10:
  print('이 Print 명령은 몇번이나 실행이 될까요?')
  cnt += 1 # 언젠가는 거짓이 될 수 있도록 ... 

print('if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. ')
```

```
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. 
```

``` python
cnt = 0

while True:
  print('이 Print 명령은 몇번이나 실행이 될까요?')

  if cnt % 2: 
    # 해당 회차를 종료하고 다음 회차로 넘어감. 
    # coninue 명령이 실행되면, continue 명령 이후의 명령어들은 실행이 안됨.
    cnt += 1
    continue
 
  if cnt > 10:
    break 
    
  cnt += 1

print('if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. ')
```

### for

- for의 기본적인 형태

``` python
for 변수 in 이터레이블:
  # for 블록
```

- 이터레이블의 원소의 개수만큼 반복
- 반복하면서 매 회차마다 이터레이블 내의 원소들을 첫 번째 원소부터 차례대로 마지막 원소까지 변수에 넣어주면서 동작

```python
mem = [10, 20, 30, 40]

for x in mem:
  print(x)
```

```
1o
20
30
40
```

#### for의 다양한 형태

- range와 함께 사용되는 경우

``` python
for i in range(5):
  print(i)
```

```
0
1
2
3
4
```

``` python
# 시퀀스 타입에 대한 인덱싱을 하는 경우
print(mem)

# 인덱싱을 통해서 리스트 내의 원소를 하나씩 참조
print(mem[0])
print(mem[1])
print(mem[2])
print(mem[3])
```

```
[10, 20, 30, 40]
10
20
30
40
```

```python
# for와 range를 이용해서 반복적으로 처리
# range를 이용해서 수열을 생성하고
# 생성된 수열을 인덱스로 활용
for i in range( len(mem) ):
  print(mem[i])
```

```
10
20
30
40
```

- List Comprehension
  - 수학적으로 집합을 정의하는 경우

``` python
# 한줄로 집합을 정의
[ x for x in range(1, 11) ]
```

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

```python
[ x * 2 for x in range(1, 11) ]
```

```
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
```

- 혹은 초기화된 리스트가 필요한 경우

```python
# 변수가 의미가 없는 경우에는 변수를 사용하지 않는다는 의미로 암묵적인 표현법
# 변수 이름 대신에 '_'를 사용해서 표현
# range에 의해서 생성되는 수열은 의미가 없고, 단순히 반복하는 횟수 정도로만 사용
[ 0 for _ in range(10) ]
```

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

# 함수(function)

-
