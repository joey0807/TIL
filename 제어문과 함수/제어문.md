# 제어문

- 거의 대부분의 언어가 비슷함
  -  2개지의 제어문을 가지고 전체 코드의 실행 흐름을 제어
  - 분기문 & 반복문

## 분기문(조건문)

- 파이썬은 `if` 하나만 제공
- 기본적인 형태

``` python
if 명제 :
[들여쓰기(tab)] 명령어들 ...
```

### 들여쓰기

- 파이썬에서는 반드시 모든 명령어들이 잘 정렬되어 있어야 한다
- 들여쓰기는 매우 중요

``` python
# 파이썬은 반드시 모든 명령어를 정렬해줘야 합니다. 
print('hello')
  print('python')
```

```
File "<ipython-input-6-45d69fab1847>", line 3
    print('python')
    ^
IndentationError: unexpected inden
```

파이썬은 블록 표현 : 들여쓰기를 이용

- 같은 들여쓰기를 해야 같은 블록으로 인식
  - 들여쓰기를 할 때, 탭과 공백을 구분
  - 반드시 같은 문자로, 같은 크기만큼 들여쓰기를 해야 함

### 다양한 형태의 if문들

```python
# 파이썬은 빈 블록을 허용하지 않음
# 블록 내에 반드시 1개 이상의 명령어를 포함해야 함
if 1 in mem:
```

```
File "<ipython-input-15-50368f684e76>", line 2
    if 1 in mem:
                ^
SyntaxError: unexpected EOF while parsing
```

```python
# 빈 블록을 작성하고 싶다면 pass를 이용
# pass를 적어주면, 예외가 발생하는 것을 막을 수 있다
if 1 in mem: 
  pass
```

#### if-else

``` python
# 거짓인 경우에 실행할 수 있는 블록을 추가
# 둘 중에 하나는 반드시 분기된다.

if 10 in mem:
  # if블록
  print('명제가 참인 경우에 실행')
else:
  # else 블록
  print('명제가 거짓인 경우에 실행')
```

```
명제가 거짓인 경우에 실행
```

if 블록과 else 블록 중에 한 곳으로는 반드시 분기됨

- 두 블록 모두 실행이 되거나, 두 블록이 모두 실행이 되지 않는 경우는 발생할 수 없음
- 무조건 어느 한 블록으로는 분기

그렇지 않다는 것은

- 두 블록이 모두 실행이 되는 경우
  - 참 거짓이 동시에 존재
  - 어떤 명제가 참인 동시에 거짓인 경우는 없음

- 두 블록이 모두 실행이 안되는 경우
  - 어떤 면제가 참 거짓이 모두 아닌 경우는 없음

#### 다중조건(elif)

``` python
# 다중조건에서는 첫번째 조건부터 차례대로 전부 비교하면서 실행
# 이때, 첫 번째로 참이 되는 블록의 명령어를 수행
# 나머지 조건은 검사하지 않습니다. 
# 한개라도 참이되는 조건이 없다면, 마지막 else 블록이 실행이 됩니다. 

# 다중조건인 경우에는 여러개의 분기중의 하나의 블록으로만 분기가 됩니다. 
if 1 in mem:
  print('참')
elif 2 in mem:
  print('참')
elif 3 in mem:
  print('참')
else:
  print('거짓')
```

```
참
```

``` python
# 다중조건이 아닙니다.
if 1 in mem:
  print('참')

if 2 in mem:
  print('참')

if 3 in mem:
  print('참')
else:
  print('거짓')
```

```
참
참
참
```

비슷한 표현을 논리연산과 함께 사용 가능

- 다중조건과 비슷하게 구현할 수 있는데
- 논리연산만으론 다중조건을 완벽하게 표현할 수 없음

``` python
if (1 in mem) or (2 in mem) or (3 in mem):
  print('참')
else:
  print('거짓')
```

```
참
```

## 반복문

- 파이썬의 2가지 형태의 반복문
  - while
  - for

### while

- 기본적인 형태는 if와 크게 다르지 않음
- if가 명제를 한번만 검사를 하고 분기를 한다면
- while은 명제를 여러번 검사함
  - 틀릴 떄 / 거짓일 때
  - 반복적으로 분기

``` python
while 명제 :
    while 블록
```

``` python
cnt = 0

# 제대로 종료가 되려면? 언젠가는 명제가 거짓이 되도록 만들어줘야 함
while cnt < 10:
  print('이 Print 명령은 몇번이나 실행이 될까요?')
  cnt += 1 # 언젠가는 거짓이 될 수 있도록 ... 

print('if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. ')
```

```
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
이 Print 명령은 몇번이나 실행이 될까요?
if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. 
```

``` python
cnt = 0

while True:
  print('이 Print 명령은 몇번이나 실행이 될까요?')

  if cnt % 2: 
    # 해당 회차를 종료하고 다음 회차로 넘어감. 
    # coninue 명령이 실행되면, continue 명령 이후의 명령어들은 실행이 안됨.
    cnt += 1
    continue
 
  if cnt > 10:
    break 
    
  cnt += 1

print('if라면 한 번만 분기되고 바로 이 명령어로 넘어오게 됩니다. ')
```

### for

- for의 기본적인 형태

``` python
for 변수 in 이터레이블:
  # for 블록
```

- 이터레이블의 원소의 개수만큼 반복
- 반복하면서 매 회차마다 이터레이블 내의 원소들을 첫 번째 원소부터 차례대로 마지막 원소까지 변수에 넣어주면서 동작

```python
mem = [10, 20, 30, 40]

for x in mem:
  print(x)
```

```
1o
20
30
40
```

#### for의 다양한 형태

- range와 함께 사용되는 경우

``` python
for i in range(5):
  print(i)
```

```
0
1
2
3
4
```

``` python
# 시퀀스 타입에 대한 인덱싱을 하는 경우
print(mem)

# 인덱싱을 통해서 리스트 내의 원소를 하나씩 참조
print(mem[0])
print(mem[1])
print(mem[2])
print(mem[3])
```

```
[10, 20, 30, 40]
10
20
30
40
```

```python
# for와 range를 이용해서 반복적으로 처리
# range를 이용해서 수열을 생성하고
# 생성된 수열을 인덱스로 활용
for i in range( len(mem) ):
  print(mem[i])
```

```
10
20
30
40
```

- List Comprehension
  - 수학적으로 집합을 정의하는 경우

``` python
# 한줄로 집합을 정의
[ x for x in range(1, 11) ]
```

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

```python
[ x * 2 for x in range(1, 11) ]
```

```
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
```

- 혹은 초기화된 리스트가 필요한 경우

```python
# 변수가 의미가 없는 경우에는 변수를 사용하지 않는다는 의미로 암묵적인 표현법
# 변수 이름 대신에 '_'를 사용해서 표현
# range에 의해서 생성되는 수열은 의미가 없고, 단순히 반복하는 횟수 정도로만 사용
[ 0 for _ in range(10) ]
```

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

# 함수(function)

- 여러 명령어들의 집합
- 프로그램을 이루는 기본 단위
- 중복되는 명령어들을 줄일 수 있고, 코드의 양이 줄어들기 때문에 효율적인 관리가 가능
- 함수에 대한 정의

``` python
def 함수이름(파라미터, 파라미터, ... ):
  # 함수 블록
```

``` python
# 가장 기본적인 함수 하나를 정의
# 파라미터도 없고, 반환도 없는 가장 기본적인 형태의 함수

# 함수의 정의(선언)
def function(): # Callee(피호출자)
  # 함수가 실행되었음을 확인할 수 있는 용도
  # print가 실행되지 않으면, 함수가 실행되지 않은 것 
  print('함수가 실행되었습니다.')
```

``` python
# 함수의 실행
# 기본적으로 호출(Call)하기 전까지는 실행이 되지 않음.

# 함수의 호출
function() # Caller(호출자)
```

```
함수가 실행되었습니다.
```

```python
# 함수의 재사용성
# 이렇게 한 번 정의된 함수는 몇번이고 반복해서 호출(실행) 가능
function()
function()
function()
function()
function()
```

```
함수가 실행되었습니다.
함수가 실행되었습니다.
함수가 실행되었습니다.
함수가 실행되었습니다.
함수가 실행되었습니다.
```

## 다양한 형태의 함수들

### 입력이 있는 함수

- Parameter(파라미터/매개변수), argument(아규먼트/인자)
- 함수를 실행하는데 필요한 입력이 있다면 파라미터를 통해 전달

```python
# 예를 들면 두 수의 합을 출력하는 함수를 정의
# 해당 함수는 반드시 두 수가 필요하겠죠

def add(a, b):
  print( a + b )
```

```python
# 입력값 전달
# 함수의 정의에 따라서, 함수 실행에 필요한 값을 호출할 때, 반드시 전달 해야 함
# 입력값을 전달 할 때는 함수에 정의된 파라미터의 개수와 순서를 맞춰서 값을 넣어주면 됨. 
# 전달은 인터프리터가 알아서 해줌. 

add(10, 20)
```

```
30
```

반드시 함수에 정의된 형태를 맞춰줘야 함

- 파라미터의 개수와 순서에 주의

``` python
# 30이라는 값을 어떤 메모리에 전달 해야 하는지 인터프리터는 알 수 없다.
add(10, 20, 30)
```

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-68-4a1b6909415d> in <module>()
      1 # 30이라는 값을 어떤 메모리에 전달 해야 하는지 인터프리터는 알 수 없습니다.
----> 2 add(10, 20, 30)

TypeError: add() takes 2 positional arguments but 3 were given
```

디폴트 파라미터

- 전달되는 값이 없으면 오류 발생
- 만약 전달되는 값이 없다면 디폴트(기본)값이 메모리에 들어가게 됨

``` python
# 함수를 정의할 때 디폴트(기본)값을 지정

def add(a=0, b=0):
  print( a + b )
```

``` python
add()
```

```
0
```

``` python
add(10)
```

```
10
```

```python
add(10, 20, 30)
```

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-72-53ac62622ed3> in <module>()
----> 1 add(10, 20, 30)

TypeError: add() takes from 0 to 2 positional arguments but 3 were given
```

디폴트 파라미터를 지정할 때 주의할 점

- 디폴트 파라미터와 그렇지 않은 파라미터를 같이 정의할 떄
  - 디폴트 파라미터가 없는 파라미터가 반드시 먼저 정의되어야 함

``` python
# 디폴트 파라미터가 정의되지 않은 경우에는 
# 해당 파라미터는 반드시 입력값을 전달하는 의미

# 입력값 한개는 무조건 전달이 되어야 하는데
# 모호한 상황이 발생.
# add(10) => 이때, 10은 a에 들어갈수도 있고, b에 들어갈수도 있다.
def add(a=0, b):
  print( a + b )
```

```
 File "<ipython-input-76-ef92896fc1d2>", line 3
    def add(a=0, b):
           ^
SyntaxError: non-default argument follows default argument
```

``` python
def add(a, b=0, c):
  print( a + b )
```

```
 File "<ipython-input-78-8e3510b01310>", line 1
    def add(a, b=0, c):
           ^
SyntaxError: non-default argument follows default argument
```

타입에 따른 입력값 전달

- 얕은 복사와 깊은 복사와 동일한 개념
- 주소 전달, 값 전달
- 기본 타입(int, float, bool)에 대한 전달 => 값 전달
- 시퀀스 타입 => 주소 전달

```python
# 파라미터로 리스트 한개를 입력받아서 
# 입력받은 리스트를 뒤집어서 출려하는 함수를 가정

def function( a ):
  a.reverse()
  print(a)
```

```python
arr = [1, 2, 3, 4]
function(arr)
```

```
[4, 3, 2, 1]
```

### 가변인자

### 반환이 있는 함수

